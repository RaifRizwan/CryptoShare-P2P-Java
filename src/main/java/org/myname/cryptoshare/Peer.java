package org.myname.cryptoshare;

import javax.crypto.Cipher;
import javax.crypto.KeyAgreement;
import javax.crypto.Mac;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.*;
import java.util.Arrays;
import java.util.Random;
import java.util.Scanner;

public class Peer {
    // Ed25519 key pair for digital signatures (used to prove identity)
    private KeyPair edKeyPair;
    // X25519 key pair for key exchange (used to derive a shared secret)
    private KeyPair xKeyPair;

    /**
     * Constructor that automatically generates both key pairs upon creation.
     */
    public Peer() throws Exception {
        generateKeys();
        System.out.println("DEBUG - Loaded local encryption key");
    }


    /**
     * Generates both the Ed25519 key pair for signing and the X25519 key pair for key exchange.
     * This method encapsulates the key generation process so that it can be reused (e.g., during key migration).
     */
    public final void generateKeys() throws Exception {
        // Generate Ed25519 key pair: fast and secure for digital signatures.
        KeyPairGenerator edKpg = KeyPairGenerator.getInstance("Ed25519");
        edKeyPair = edKpg.generateKeyPair();

        // Generate X25519 key pair: used for Diffieâ€“Hellman key exchange.
        KeyPairGenerator xKpg = KeyPairGenerator.getInstance("X25519");
        xKeyPair = xKpg.generateKeyPair();
    }

    /**
     * Generates a random challenge (a series of bytes) for the purpose of mutual authentication.
     * The challenge is sent to another peer, which must sign it using its private key.
     *
     * @return a randomly generated byte array (challenge)
     */
    public byte[] generateChallenge() {
        byte[] challenge = new byte[16]; // 16-byte challenge
        new SecureRandom().nextBytes(challenge); // Fill with cryptographically secure random bytes
        return challenge;
    }

    /**
     * Signs the provided challenge using the peer's Ed25519 private key.
     *
     * @param challenge The byte array representing the challenge.
     * @return The digital signature as a byte array.
     * @throws Exception if signing fails.
     */
    public byte[] signChallenge(byte[] challenge) throws Exception {
        Signature signer = Signature.getInstance("Ed25519");
        signer.initSign(edKeyPair.getPrivate());
        signer.update(challenge);
        return signer.sign();
    }

    /**
     * Verifies that the provided signature matches the given challenge using the sender's public key.
     *
     * @param challenge The original challenge sent.
     * @param signature The signature generated by the sender.
     * @param publicKey The sender's public key.
     * @return true if the signature is valid, false otherwise.
     * @throws Exception if verification fails.
     */
    public boolean verifyChallenge(byte[] challenge, byte[] signature, PublicKey publicKey) throws Exception {
        Signature verifier = Signature.getInstance("Ed25519");
        verifier.initVerify(publicKey);
        verifier.update(challenge);
        return verifier.verify(signature);
    }

    /**
     * Computes a shared secret using the X25519 private key of this peer and the public key of the other peer.
     * This shared secret is then used to derive a symmetric AES key.
     *
     * @param otherXPublic The other peer's X25519 public key.
     * @return The computed shared secret as a byte array.
     * @throws Exception if key agreement fails.
     */
    public byte[] computeSharedSecret(PublicKey otherXPublic) throws Exception {
        KeyAgreement ka = KeyAgreement.getInstance("X25519");
        ka.init(xKeyPair.getPrivate());
        ka.doPhase(otherXPublic, true);
        return ka.generateSecret();
    }

    /**
     * Derives a 128-bit AES key from a shared secret using HKDF.
     * A fixed salt and contextual information ("info") are used for this derivation.
     *
     * @param sharedSecret The shared secret from key exchange.
     * @return A 128-bit AES key as a byte array.
     * @throws Exception if key derivation fails.
     */
    public byte[] deriveAESKey(byte[] sharedSecret) throws Exception {
        byte[] salt = new byte[32];
        Arrays.fill(salt, (byte) 0);
        byte[] info = "AES key derivation".getBytes(StandardCharsets.UTF_8);
        int aesKeyLength = 16;  // 16 bytes = 128-bit AES key
        return HKDF.deriveKey("HmacSHA256", salt, sharedSecret, info, aesKeyLength);
    }

    /**
     * Signs arbitrary data using the peer's Ed25519 private key.
     *
     * @param data The data to sign.
     * @return The generated digital signature.
     * @throws Exception if signing fails.
     */
    public byte[] signData(byte[] data) throws Exception {
        Signature signer = Signature.getInstance("Ed25519");
        signer.initSign(edKeyPair.getPrivate());
        signer.update(data);
        return signer.sign();
    }

    /**
     * Verifies a digital signature for given data using a provided public key.
     *
     * @param data The original data.
     * @param signature The signature to verify.
     * @param publicKey The public key of the signer.
     * @return true if the signature is valid; false otherwise.
     * @throws Exception if verification fails.
     */
    public boolean verifySignature(byte[] data, byte[] signature, PublicKey publicKey) throws Exception {
        Signature verifier = Signature.getInstance("Ed25519");
        verifier.initVerify(publicKey);
        verifier.update(data);
        return verifier.verify(signature);
    }

    /**
     * Encrypts data using AES in Galois/Counter Mode (GCM), which provides both confidentiality and integrity.
     * A new 12-byte nonce is generated for each encryption operation.
     *
     * @param aesKey The AES key to use for encryption.
     * @param data The plaintext data to encrypt.
     * @return An EncryptionResult object containing the nonce and ciphertext.
     * @throws Exception if encryption fails.
     */
    public EncryptionResult encryptData(byte[] aesKey, byte[] data) throws Exception {
        SecureRandom random = new SecureRandom();
        byte[] nonce = new byte[12]; // AES-GCM requires a 12-byte nonce for optimal security.
        random.nextBytes(nonce); // Generate a fresh random nonce.
        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        SecretKeySpec keySpec = new SecretKeySpec(aesKey, "AES");
        GCMParameterSpec gcmSpec = new GCMParameterSpec(128, nonce); // 128-bit authentication tag.
        cipher.init(Cipher.ENCRYPT_MODE, keySpec, gcmSpec);
        byte[] ciphertext = cipher.doFinal(data);
        return new EncryptionResult(nonce, ciphertext);
    }

    /**
     * Decrypts data encrypted with AES-GCM.
     *
     * @param aesKey The AES key used during encryption.
     * @param nonce The nonce that was used for encryption.
     * @param ciphertext The encrypted data.
     * @return The decrypted plaintext data.
     * @throws Exception if decryption fails.
     */
    public byte[] decryptData(byte[] aesKey, byte[] nonce, byte[] ciphertext) throws Exception {
        Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
        SecretKeySpec keySpec = new SecretKeySpec(aesKey, "AES");
        GCMParameterSpec gcmSpec = new GCMParameterSpec(128, nonce);
        cipher.init(Cipher.DECRYPT_MODE, keySpec, gcmSpec);
        return cipher.doFinal(ciphertext);
    }

    /**
     * Simulates key migration by regenerating the peer's key pairs.
     * In a real application, this would also involve notifying all contacts of the new keys.
     */
    public void migrateKeys() throws Exception {
        System.out.println("Migrating keys...");
        generateKeys(); // Regenerate both Ed25519 and X25519 key pairs.
        System.out.println("Keys migrated. Contacts notified.");
    }

    /**
     * Getter for the Ed25519 key pair.
     * @return The Ed25519 key pair.
     */
    public KeyPair getEdKeyPair() {
        return edKeyPair;
    }

    /**
     * Getter for the X25519 key pair.
     * @return The X25519 key pair.
     */
    public KeyPair getXKeyPair() {
        return xKeyPair;
    }

    /**
     * Starts the peer, printing a message to indicate readiness.
     */
    public void start() {
        String peerId = "peer_01";
        int port = 9000;
        System.out.println("DEBUG - Peer '" + peerId + "' initialized on port " + port);
        System.out.println("DEBUG - Starting broadcast and discovery services");
    }

    /**
     * A container class to hold the results of an encryption operation.
     * It stores both the nonce (needed for decryption) and the ciphertext.
     */
    public static class EncryptionResult {
        public final byte[] nonce;
        public final byte[] ciphertext;

        public EncryptionResult(byte[] nonce, byte[] ciphertext) {
            this.nonce = nonce;
            this.ciphertext = ciphertext;
        }
    }

    /**
     * A simple implementation of the HKDF (HMAC-based Key Derivation Function).
     * This method extracts a pseudorandom key from the input keying material (ikm) and expands it to produce the desired key length.
     */
    public static class HKDF {
        public static byte[] deriveKey(String hmacAlgorithm, byte[] salt, byte[] ikm, byte[] info, int length) throws Exception {
            Mac mac = Mac.getInstance(hmacAlgorithm);
            // If no salt is provided, initialize it to an array of zeros.
            if (salt == null || salt.length == 0) {
                salt = new byte[mac.getMacLength()];
                Arrays.fill(salt, (byte) 0);
            }
            SecretKeySpec saltKey = new SecretKeySpec(salt, hmacAlgorithm);
            mac.init(saltKey);
            // HKDF-Extract: Derive a pseudorandom key (PRK) from the input keying material.
            byte[] prk = mac.doFinal(ikm);

            // HKDF-Expand: Generate the final key from the PRK, using the provided context information.
            byte[] result = new byte[length];
            byte[] t = new byte[0];
            int loc = 0;
            int counter = 1;
            // Loop until we have generated enough key material.
            while (loc < length) {
                mac.init(new SecretKeySpec(prk, hmacAlgorithm));
                mac.update(t);
                mac.update(info);
                mac.update((byte) counter);
                t = mac.doFinal();
                int copyLength = Math.min(t.length, length - loc);
                System.arraycopy(t, 0, result, loc, copyLength);
                loc += copyLength;
                counter++;
            }
            return result;
        }
    }
}

